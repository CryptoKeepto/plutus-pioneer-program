

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>4. Week 03 - Script Context &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Week 04 - Monads" href="week4.html" />
    <link rel="prev" title="3. Week 02 - Validation" href="week2.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="week1.html">2. Week 01 - English Auction</a></li>
<li class="toctree-l1"><a class="reference internal" href="week2.html">3. Week 02 - Validation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Week 03 - Script Context</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#before-we-start">4.1. Before We Start</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recap">4.2. Recap</a></li>
<li class="toctree-l2"><a class="reference internal" href="#scriptcontext">4.3. ScriptContext</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#txinfovalidrange">4.3.1. txInfoValidRange</a></li>
<li class="toctree-l3"><a class="reference internal" href="#posixtimerange">4.3.2. POSIXTimeRange</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#example-vesting">4.4. Example - Vesting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#in-the-playground">4.4.1. In the playground</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#example-2-parameterized-contract">4.5. Example 2 - Parameterized Contract</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#an-observation">4.5.1. An Observation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#another-way-of-doing-it">4.5.2. Another Way of Doing It</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-lift-class">4.5.2.1. The Lift Class</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#back-to-the-playground">4.5.3. Back to the playground</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="week4.html">5. Week 04 - Monads</a></li>
<li class="toctree-l1"><a class="reference internal" href="week5.html">6. Week 05 - Native Tokens</a></li>
<li class="toctree-l1"><a class="reference internal" href="week6.html">7. Week 06 - Oracles</a></li>
<li class="toctree-l1"><a class="reference internal" href="week7.html">8. Week 07 - State Machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="week8.html">9. Week 08 - Property Based Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="week9.html">10. Week 09 - Marlowe</a></li>
<li class="toctree-l1"><a class="reference internal" href="week10.html">11. Week 10 - Uniswap</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">4. </span>Week 03 - Script Context</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/week3.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="week-03-script-context">
<h1><span class="section-number">4. </span>Week 03 - Script Context<a class="headerlink" href="#week-03-script-context" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://www.youtube.com/watch?v=6_rfCCY9_gY">Lecture
#3, Iteration #2</a>.</p>
<p>In this lecture we learn about the script context (the third validation
argument), handling time, and parameterized contracts.</p>
<p>The code in this lecture uses Plutus commit <code class="docutils literal notranslate"><span class="pre">81ba78edb1d634a13371397d8c8b19829345ce0d</span></code>.</p>
</div>
<div class="section" id="before-we-start">
<h2><span class="section-number">4.1. </span>Before We Start<a class="headerlink" href="#before-we-start" title="Permalink to this headline">¶</a></h2>
<p>Since the last lecture there has been an update to the playground, which is present in the Plutus commit we are using for this lecture (see note above).</p>
<p>There was an issue whereby the timeout, which has hardcoded into the playground was too short. This would cause simulations to fail if they took longer than the
hardcoded timeout.</p>
<p>There is now an option when you start the Plutus Playground Server which allows you to specify the timeout. The following example sets the timeout to 120 seconds.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plutus</span><span class="o">-</span><span class="n">playground</span><span class="o">-</span><span class="n">server</span> <span class="o">-</span><span class="n">i</span> <span class="mi">120</span><span class="n">s</span>
</pre></div>
</div>
</div>
<div class="section" id="recap">
<h2><span class="section-number">4.2. </span>Recap<a class="headerlink" href="#recap" title="Permalink to this headline">¶</a></h2>
<p>When we explained the (E)UTxO model in the first lecture, we mentioned that in
order to unlock a script address, the script attached to the address is
run, and that script gets three pieces of information - the <em>Datum</em>, the
<em>Redeemer</em> and the <em>Context</em>.</p>
<p>In the second lecture, we saw examples of that, and we saw how it
actually works in Haskell.</p>
<p>We saw the low-level implementation, where all three arguments are
represented by the <code class="docutils literal notranslate"><span class="pre">Data</span></code> type. We also saw that in practice this is not
used.</p>
<p>Instead, we use the typed version, where the datum and redeemer* can be
custom types (as long as they implement the <code class="docutils literal notranslate"><span class="pre">IsData</span></code> type class), and
where the third argument is of type <code class="docutils literal notranslate"><span class="pre">ScriptContext</span></code>.</p>
<p>In the examples we have seen so far we have looked at the datum and
the redeemer, but we have always ignored the context. But the
context is, of course, very important. So, in this lecture we will
start looking at the context.</p>
</div>
<div class="section" id="scriptcontext">
<h2><span class="section-number">4.3. </span>ScriptContext<a class="headerlink" href="#scriptcontext" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">ScriptContext</span></code> type is defined in package <code class="docutils literal notranslate"><span class="pre">plutus-ledger-api</span></code>,
which is a package that, until now, we haven’t needed. But now we do
need it, and it is included in this week’s <code class="docutils literal notranslate"><span class="pre">.cabal</span></code> file. It is
defined in module <code class="docutils literal notranslate"><span class="pre">Plutus.V1.Ledger.Contexts</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptContext</span> <span class="ow">=</span> <span class="kt">ScriptContext</span> <span class="p">{</span>
            <span class="n">scriptContextTxInfo</span> <span class="ow">::</span> <span class="kt">TxInfo</span><span class="p">,</span>
            <span class="n">scriptContextPurpose</span> <span class="ow">::</span> <span class="kt">ScriptPurpose</span>
      <span class="p">}</span>
</pre></div>
</div>
<p>It is a record type with two fields.</p>
<p>The second field is of type <code class="docutils literal notranslate"><span class="pre">ScriptPurpose</span></code>, which is defined in the same module. It defines for which purpose a script is being run.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptPurpose</span>
   <span class="ow">=</span> <span class="kt">Minting</span> <span class="kt">CurrencySymbol</span>
   <span class="o">|</span> <span class="kt">Spending</span> <span class="kt">TxOutRef</span>
   <span class="o">|</span> <span class="kt">Rewarding</span> <span class="kt">StakingCredential</span>
   <span class="o">|</span> <span class="kt">Certifying</span> <span class="kt">DCert</span>
</pre></div>
</div>
<p>For us, the most important is <code class="docutils literal notranslate"><span class="pre">Spending</span></code>. This is what we have talked
about so far in the context of the (E)UTxO model. This is when a script
is run in order to validate a spending input for a transaction.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Minting</span></code> purpose comes into play when you want to define a native
token. Its purpose us to describe under which circumstances the native
token can be minted or burned.</p>
<p>There are also two new brand new purposes - <code class="docutils literal notranslate"><span class="pre">Rewarding</span></code> - related to
staking and <code class="docutils literal notranslate"><span class="pre">Certifying</span></code> - related to stake delegation.</p>
<p>The most interesting field, the one that contains the actual context, is <code class="docutils literal notranslate"><span class="pre">scriptContextTxInfo</span></code>, which is of type
<code class="docutils literal notranslate"><span class="pre">TxInfo</span></code>, also defined in the same module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TxInfo</span> <span class="ow">=</span> <span class="kt">TxInfo</span>
   <span class="p">{</span> <span class="n">txInfoInputs</span>      <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">]</span> <span class="c1">-- ^ Transaction inputs</span>
   <span class="p">,</span> <span class="n">txInfoOutputs</span>     <span class="ow">::</span> <span class="p">[</span><span class="kt">TxOut</span><span class="p">]</span> <span class="c1">-- ^ Transaction outputs</span>
   <span class="p">,</span> <span class="n">txInfoFee</span>         <span class="ow">::</span> <span class="kt">Value</span> <span class="c1">-- ^ The fee paid by this transaction.</span>
   <span class="p">,</span> <span class="n">txInfoForge</span>       <span class="ow">::</span> <span class="kt">Value</span> <span class="c1">-- ^ The &#39;Value&#39; forged by this transaction.</span>
   <span class="p">,</span> <span class="n">txInfoDCert</span>       <span class="ow">::</span> <span class="p">[</span><span class="kt">DCert</span><span class="p">]</span> <span class="c1">-- ^ Digests of certificates included in this transaction</span>
   <span class="p">,</span> <span class="n">txInfoWdrl</span>        <span class="ow">::</span> <span class="p">[(</span><span class="kt">StakingCredential</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">)]</span> <span class="c1">-- ^ Withdrawals</span>
   <span class="p">,</span> <span class="n">txInfoValidRange</span>  <span class="ow">::</span> <span class="kt">SlotRange</span> <span class="c1">-- ^ The valid range for the transaction.</span>
   <span class="p">,</span> <span class="n">txInfoSignatories</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">PubKeyHash</span><span class="p">]</span> <span class="c1">-- ^ Signatures provided with the transaction, attested that they all signed the tx</span>
   <span class="p">,</span> <span class="n">txInfoData</span>        <span class="ow">::</span> <span class="p">[(</span><span class="kt">DatumHash</span><span class="p">,</span> <span class="kt">Datum</span><span class="p">)]</span>
   <span class="p">,</span> <span class="n">txInfoId</span>          <span class="ow">::</span> <span class="kt">TxId</span>
   <span class="c1">-- ^ Hash of the pending transaction (excluding witnesses)</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
</pre></div>
</div>
<p>It describes the spending transaction. In the (E)UTxO model, the context of validation is the spending transaction and its
inputs and outputs. This context is expressed in the <code class="docutils literal notranslate"><span class="pre">TxInfo</span></code> type.</p>
<p>There are a couple of fields that are global to the whole transaction and in particular we have the list of all the inputs <code class="docutils literal notranslate"><span class="pre">txInfoInputs</span></code>
and the list of all the outputs <code class="docutils literal notranslate"><span class="pre">txInfoOutputs</span></code>. Each of those has a variety of fields to drill into each individual input or output.</p>
<p>We also see fields for fees <code class="docutils literal notranslate"><span class="pre">txFee</span></code>, the forge value <code class="docutils literal notranslate"><span class="pre">txInfoForge</span></code>, used when minting or burning native tokens.</p>
<p>Then we have a list of delegation certificates in <code class="docutils literal notranslate"><span class="pre">txInfoDCert</span></code> and a field <code class="docutils literal notranslate"><span class="pre">txInfoWdrl</span></code> to hold information about staking withdrawals.</p>
<p>The field <code class="docutils literal notranslate"><span class="pre">txInfoValidRange</span></code>, which we will look at in much more detail in a moment, defines the slot range for which this transaction is valid.</p>
<p><code class="docutils literal notranslate"><span class="pre">txInfoSignatories</span></code> is the list of public keys that have signed this transaction.</p>
<p>Transactions that spend a script output need to include the datum of the script output.
The <code class="docutils literal notranslate"><span class="pre">txInfoData</span></code> field is a list associating datums with their respective hashes. If there is a transaction output to a script address
that carries some datum, you don’t need to include the datum, you can just include the datum hash. However, scripts that spend an output do need to include the datum, in which case it will be included in the <code class="docutils literal notranslate"><span class="pre">txInfoData</span></code> list.</p>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">txInfoId</span></code> field is the ID of this transaction.</p>
<div class="section" id="txinfovalidrange">
<h3><span class="section-number">4.3.1. </span>txInfoValidRange<a class="headerlink" href="#txinfovalidrange" title="Permalink to this headline">¶</a></h3>
<p>While there is a lot of information contained in this <code class="docutils literal notranslate"><span class="pre">txInfo</span></code> type, for
our first example of how to use the third argument to validation, we
will concentrate on the <code class="docutils literal notranslate"><span class="pre">txInfoValidRange</span></code> field.</p>
<p>This brings us to an interesting dilemma. We have stressed several times
that the big advantage that Cardano has over something like Ethereum is
that validation can happen in the wallet. But we have also noted that a
transaction can still fail on-chain following validation if, when the
transaction arrives on the blockchain, it has been consumed already by
someone else. In this case, the transaction fails without having to pay
fees.</p>
<p>What should never happen under normal circumstances is that a validation
script runs and then fails. This is because you can always run the
validation under exactly the same conditions in the wallet, so it would
fail before you ever submit it.</p>
<p>So that is a very nice feature, but it is not obvious how to manage time
in that context. Time is important, because we want to be able to
express that a certain transaction is only valid before or only valid
after a certain time has been reached.</p>
<p>We saw an example of this in lecture one - the auction example, where
bids are only allowed until the deadline has been reached, and the
<code class="docutils literal notranslate"><span class="pre">close</span></code> endpoint can only be called after the deadline has passed.</p>
<p>That seems to be a contradiction, because time is obviously flowing. So,
when you try to validate a transaction that you are constructing in your
wallet, the time that you are doing that can, of course, be different
than the time that the transaction arrives at a node for validation. So,
it’s not clear how to bring these two together so that validation is
deterministic, and to guarantee that if, and only if, validation
succeeds in the wallet, it will also succeed in the node.</p>
<p>The way Cardano solves that, is by adding the slot range field
<code class="docutils literal notranslate"><span class="pre">txInfoValidRange</span></code> to a transaction, which essentially says “This
transaction is valid between <em>this</em> and <em>that</em> slot”.</p>
<p>When a transaction gets submitted to the blockchain and validated by a
node, then before any scripts are run, some general checks are made, for
example that all inputs are present and that the balances add up, that
the fees are included and so on.</p>
<p>One of those checks that happens before validation is to check that the slot range is valid. The
node will look at the current time and check that it falls into the valid slot range of the transaction. If it does not, then validation fails immediately without
ever running the validator scripts.</p>
<p>So, if the pre-checks succeed, then this means that the current time does fall into the valid slot range.
This, in turn, means that we are completely deterministic again. The validation script can simply assume that it is being run at a valid slot.</p>
<p>By default, a script will use the infinite slot range, one that covers all slots starting from the genesis block and running until the end of time.</p>
<p>There is one slight complication with this, and that is that Ouroboros, the consensus protocol powering Cardano doesn’t use POSIX time, it uses slots. But Plutus
uses real time, so we need to be able to convert back and forth between real time and slots. This is no problem so long as the slot time is fixed. Right now it is
one second, so right now it is easy.</p>
<p>However, this could change in the future. There could be a hard fork with some parameter change that would change the slot time. We can’t know that in advance.
We don’t know what the slot length will be in ten years, for example.</p>
<p>That means that slot intervals that are defined for transactions mustn’t have a definite upper bound that is too far in the future. It must only be as far in the
future as it is possible to know what the slot length will be. This happens to be something like 36 hours. We know that if there is going to be a hard fork, we would
know about it at least 36 hours in advance.</p>
</div>
<div class="section" id="posixtimerange">
<h3><span class="section-number">4.3.2. </span>POSIXTimeRange<a class="headerlink" href="#posixtimerange" title="Permalink to this headline">¶</a></h3>
<p>Let’s look at this <code class="docutils literal notranslate"><span class="pre">POSIXTimeRange</span></code> type, which is defined in <code class="docutils literal notranslate"><span class="pre">Plutus.V1.Ledger.Time</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">POSIXTimeRange</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="kt">POSIXTime</span><span class="o">.</span>
</pre></div>
</div>
<p>It is a type synonym for <code class="docutils literal notranslate"><span class="pre">Interval</span> <span class="pre">POSIXTime</span></code> and we see that <code class="docutils literal notranslate"><span class="pre">Interval</span></code> is defined by a <code class="docutils literal notranslate"><span class="pre">LowerBound</span></code> and an <code class="docutils literal notranslate"><span class="pre">UpperBound</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Interval</span>
      <span class="n">ivFrom</span> <span class="ow">::</span> <span class="kt">LowerBound</span> <span class="n">a</span>
      <span class="n">inTo</span>   <span class="ow">::</span> <span class="kt">UpperBound</span> <span class="n">a</span>
</pre></div>
</div>
<p>If we drill into <code class="docutils literal notranslate"><span class="pre">LowerBound</span></code> we see the constructor</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">LowerBound</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LowerBound</span> <span class="p">(</span><span class="kt">Extended</span> <span class="n">a</span><span class="p">)</span> <span class="kt">Closure</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Closure</span></code> is a synonym for <code class="docutils literal notranslate"><span class="pre">Bool</span></code> and specifies whether a bound is included in the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> or not.</p>
<p><code class="docutils literal notranslate"><span class="pre">Extended</span></code> can be <code class="docutils literal notranslate"><span class="pre">NegInf</span></code> for negative infinity, <code class="docutils literal notranslate"><span class="pre">PosInf</span></code> for positive infinity, or <code class="docutils literal notranslate"><span class="pre">Finite</span> <span class="pre">a</span></code>.</p>
<p>We also find some helper functions including the <code class="docutils literal notranslate"><span class="pre">member</span></code> function which checks if a given <code class="docutils literal notranslate"><span class="pre">a</span></code> is part of a given <code class="docutils literal notranslate"><span class="pre">Interval</span></code>, so long as the type of <code class="docutils literal notranslate"><span class="pre">a</span></code> is a subtype
of <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, which is the case for <code class="docutils literal notranslate"><span class="pre">POSIXTime</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">member</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">member</span> <span class="n">a</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">i</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">singleton</span> <span class="n">a</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">interval</span></code> is a smart constructor for the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> type which creates an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> with an inclusive upper and lower bound.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">interval</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">interval</span> <span class="n">s</span> <span class="n">s&#39;</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">lowerBound</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="n">upperBound</span> <span class="n">s&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we have <code class="docutils literal notranslate"><span class="pre">from</span></code> which constructs an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> which starts at <code class="docutils literal notranslate"><span class="pre">a</span></code> and lasts until eternity.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">from</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">from</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">lowerBound</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="kt">UpperBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>And we have <code class="docutils literal notranslate"><span class="pre">to</span></code>, which is the opposite. It constructs an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> starting from the genesis block up to, and including <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">to</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">to</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="kt">LowerBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="n">upperBound</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">always</span></code> is the default <code class="docutils literal notranslate"><span class="pre">Interval</span></code> which includes all times.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">always</span> <span class="ow">::</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">always</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="kt">LowerBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="kt">UpperBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>And we have the opposite, <code class="docutils literal notranslate"><span class="pre">never</span></code>, which contains no slots.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">never</span> <span class="ow">::</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">never</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="kt">LowerBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="kt">UpperBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>There is also the <code class="docutils literal notranslate"><span class="pre">singleton</span></code> helper, which constructs an interval which consists of just one slot.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">singleton</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">singleton</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">interval</span> <span class="n">s</span> <span class="n">s</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">hull</span></code> gives the smallest interval containing both the given intervals.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">hull</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">hull</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l1</span> <span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l2</span> <span class="n">h2</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">min</span> <span class="n">l1</span> <span class="n">l2</span><span class="p">)</span> <span class="p">(</span><span class="n">max</span> <span class="n">h1</span> <span class="n">h2</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">intersection</span></code> function determines the largest interval that is contained in both the given intervals. This is an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> that starts
from the largest lower bound of the two intervals and extends until the smallest upper bound.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">intersection</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">intersection</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l1</span> <span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l2</span> <span class="n">h2</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">max</span> <span class="n">l1</span> <span class="n">l2</span><span class="p">)</span> <span class="p">(</span><span class="n">min</span> <span class="n">h1</span> <span class="n">h2</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">overlaps</span></code> function checks whether two intervals overlap, that is, whether there is a value that is a member of both intervals.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">overlaps</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">overlaps</span> <span class="n">l</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">isEmpty</span> <span class="p">(</span><span class="n">l</span> <span class="p">`</span><span class="n">intersection</span><span class="p">`</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">contains</span></code> takes two intervals and determines if the second interval is completely contained within the first one.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">contains</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">contains</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l1</span> <span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l2</span> <span class="n">h2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">l1</span> <span class="o">&lt;=</span> <span class="n">l2</span> <span class="o">&amp;&amp;</span> <span class="n">h2</span> <span class="o">&lt;=</span> <span class="n">h1</span>
</pre></div>
</div>
<p>And we have the <code class="docutils literal notranslate"><span class="pre">before</span></code> and <code class="docutils literal notranslate"><span class="pre">after</span></code> functions to determine, if a given time is, respectively, before or after everything in a given <code class="docutils literal notranslate"><span class="pre">Interval</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">before</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">before</span> <span class="n">h</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">f</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lowerBound</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">f</span>

<span class="nf">after</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">after</span> <span class="n">h</span> <span class="p">(</span><span class="kt">Interval</span> <span class="kr">_</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="n">upperBound</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">t</span>
</pre></div>
</div>
<p>Let’s have a play in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.V1.Ledger.Interval</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Let’s construct the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> between 10 and 20, inclusive.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="ow">=</span> <span class="kt">LowerBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="mi">10</span><span class="p">)</span> <span class="kt">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="ow">=</span> <span class="kt">UpperBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="mi">20</span><span class="p">)</span> <span class="kt">True</span><span class="p">}</span>
</pre></div>
</div>
<p>We can check whether a value is a member of an interval:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">9</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">10</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">12</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">20</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">21</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>We can use the <code class="docutils literal notranslate"><span class="pre">from</span></code> constructor. Here the lower bound is again a finite slot, but the upper bound is positive infinity.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">21</span> <span class="o">$</span> <span class="n">from</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">30</span> <span class="o">$</span> <span class="n">from</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">300000</span> <span class="o">$</span> <span class="n">from</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>And the <code class="docutils literal notranslate"><span class="pre">to</span></code> constructor. Here the lower bound is negative infinity, while the upper bound is a finite slot number.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">300000</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">31</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">30</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">7</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>Now, let’s try the <code class="docutils literal notranslate"><span class="pre">intersection</span></code> function on the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> from 10 to 20 and the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> from 18 to 30.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">intersection</span> <span class="p">(</span><span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span><span class="p">)</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">18</span> <span class="mi">30</span>
<span class="kt">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="ow">=</span> <span class="kt">LowerBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="mi">18</span><span class="p">)</span> <span class="kt">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="ow">=</span> <span class="kt">UpperBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="mi">20</span><span class="p">)</span> <span class="kt">True</span><span class="p">}</span>
</pre></div>
</div>
<p>As expected, we get the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> that runs from 18 to 20, inclusive.</p>
<p>We can check whether one <code class="docutils literal notranslate"><span class="pre">Interval</span></code> contains another.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">contains</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">80</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">contains</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">100</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">contains</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">101</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>We see that as soon as the second <code class="docutils literal notranslate"><span class="pre">Interval</span></code> extends to 101, it is no longer fully contained within the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> that runs to 100.</p>
<p>However, if we check with <code class="docutils literal notranslate"><span class="pre">overlaps</span></code>, then it will be true because there are elements, such as 40, that are contained in both intervals.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">overlaps</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">101</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">overlaps</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">101</span> <span class="mi">110</span>
<span class="kt">False</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="example-vesting">
<h2><span class="section-number">4.4. </span>Example - Vesting<a class="headerlink" href="#example-vesting" title="Permalink to this headline">¶</a></h2>
<p>Imagine you want to give a gift of Ada to a child. You want the child to own the Ada, but you only want the child to have access to it he or she
turns eighteen.</p>
<p>Using Plutus, it is very easy to implement. As our first contract that will look at the context argument, we will
implement a contract that implements a vesting scheme. Money will be put into a script and then it can be retrieved by a certain person, but only once
a certain deadline has been reached.</p>
<p>We start by copying the <code class="docutils literal notranslate"><span class="pre">IsData</span></code> contract from lecture two into a new module called <code class="docutils literal notranslate"><span class="pre">Vesting</span></code>.</p>
<p>The first step is to think about the types for the datum and redeemer.</p>
<p>For datum, it makes sense to have two pieces of information, the beneficiary and the deadline. So, let’s define this type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">VestingDatum</span> <span class="ow">=</span> <span class="kt">VestingDatum</span>
   <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span>
   <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">::</span> <span class="kt">POSIXTime</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kt">PlutusTx</span><span class="o">.</span><span class="n">unstableMakeIsData</span> <span class="kt">&#39;&#39;VestingDatum</span>
</pre></div>
</div>
<p>In order to know if someone can spend this script output, two pieces information are required, i.e. the beneficiary’s signature and the time of the transaction. In
this case, both those pieces of information are contained in the transaction itself. This means that we don’t need any information in the redeemer, so we can just
use <code class="docutils literal notranslate"><span class="pre">()</span></code> for the redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">VestingDatum</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>We need to check two conditions.</p>
<ol class="arabic simple">
<li><p>That only the correct beneficiary can unlock a UTxO sitting at this
address. This we can validate by checking that the beneficiary’s
signature is included in the transaction.</p></li>
<li><p>That this transaction is only executed after the deadline is reached.</p></li>
</ol>
<p>We could probably just write this in one go, but we will write it in a
more top-down fashion and delegate to some helper functions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="n">dat</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span>
      <span class="n">mkValidator</span> <span class="n">dat</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;beneficiary&#39;s signature missing&quot;</span> <span class="n">signedByBeneficiary</span> <span class="o">&amp;&amp;</span>
                               <span class="n">traceIfFalse</span> <span class="s">&quot;deadline not reached&quot;</span> <span class="n">deadlineReached</span>
<span class="kr">where</span>
      <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
      <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>
</pre></div>
</div>
<p>To check that the transaction is signed by the beneficiary, we can get the public key of the beneficiary from the datum and pass it, along with the transaction
information to the <code class="docutils literal notranslate"><span class="pre">txSignedBy</span></code> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signedByBeneficiary</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">signedByBeneficiary</span> <span class="ow">=</span> <span class="n">txSignedBy</span> <span class="n">info</span> <span class="o">$</span> <span class="n">beneficiary</span> <span class="n">dat</span>
</pre></div>
</div>
<p>How do we check that the deadline has passed?</p>
<div class="figure align-default">
<img alt="_images/pic__000461.png" src="_images/pic__000461.png" />
</div>
<p>Let’s consider a transaction with a validity that crosses the deadline, which is shown as the uppermost range in the above diagram.</p>
<p>Recall that before the validator script is run, other checks are made, including the time check. The node checks that the current time falls into the valid range of
the transaction and only then is the validator run. So we know that, if we are in the validator, the current time lies somewhere within the validity interval.</p>
<p>In the case of the range that crosses the deadline, the validator code cannot know whether the current time is before or after the deadline. In this case, the
validator must declare that the transaction is invalid.</p>
<p>The second example in the diagram, however, is fine. We still don’t know what the current time is exactly, but we know that whatever the time is, it will be after the
deadline.</p>
<p>So, what we are checking for is that the whole validity interval is to the right of the deadline. One way to do this is to use the <code class="docutils literal notranslate"><span class="pre">contains</span></code> function to check
whether the validity interval is fully contained within the interval that starts from the deadline and extends until the end of time.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">deadlineReached</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">deadlineReached</span> <span class="ow">=</span> <span class="n">contains</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="n">deadline</span> <span class="n">dat</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoValidRange</span> <span class="n">info</span>
</pre></div>
</div>
<p>Let’s look back at the <code class="docutils literal notranslate"><span class="pre">ScriptContext</span></code> type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptContext</span> <span class="ow">=</span> <span class="kt">ScriptContext</span><span class="p">{</span><span class="n">scriptContextTxInfo</span> <span class="ow">::</span> <span class="kt">TxInfo</span><span class="p">,</span> <span class="n">scriptContextPurpose</span> <span class="ow">::</span> <span class="kt">ScriptPurpose</span> <span class="p">}</span>
</pre></div>
</div>
<p>We are not interest in the script purpose, as we know that it is a
spending script. The interesting one for us here is <em>TxInfo</em>, as this
provides both the signatures and the timing information.</p>
<p>So let’s add a helper function that gets this for us from our third
argument - <em>ctx</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="n">dat</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span>
   <span class="n">traceIfFalse</span> <span class="s">&quot;beneficiary&#39;s signature missing&quot;</span> <span class="n">checkSig</span>      <span class="o">&amp;&amp;</span>
   <span class="n">traceIfFalse</span> <span class="s">&quot;deadline not reached&quot;</span>            <span class="n">checkDeadline</span>
<span class="kr">where</span>
   <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
   <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>
   <span class="o">...</span>
   <span class="n">checkSig</span> <span class="ow">::</span> <span class="kt">Bool</span>
   <span class="o">...</span>
   <span class="n">checkDeadline</span> <span class="ow">::</span> <span class="kt">Bool</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>For the first helper function, <em>checkSig</em>, we must check that the
beneficiary has signed the transaction.</p>
<p>Here we use the <code class="docutils literal notranslate"><span class="pre">elem</span></code> function here from the Plutus Prelude, which is
a copy of the same function from the standard Prelude. You will recall
that this is because it is not possible to make functions in standard
Prelude INLINABLE, which is required for our validation scripts to
compile.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkSig</span> <span class="ow">=</span> <span class="n">beneficiary</span> <span class="n">dat</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">txInfoSignatories</span> <span class="n">info</span>
</pre></div>
</div>
<p>To check the deadline we need the <em>txInfoValidRange</em> field of <em>TxInfo</em>,
which gives us a value of type <em>SlotRange</em>.</p>
<p>We must check that this transaction is only submitted once the deadline
has been reached.</p>
<p>As we saw before, the way time is handled is that, during validation,
before any script is run, it is checked that this range that the
transaction gives actually includes the current slot.</p>
<p>We don’t know exactly what the current slot is because the interval may
be large, but what we do know is that one of those slots is the current
time.</p>
<p>So, in order to make sure that the deadline has been reached, we must
check that all the slots in the slot range are after the deadline. And
one way to do this, is to ask if the valid slot range is included in the
interval that starts at the deadline and extends to the end of time.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkDeadline</span> <span class="ow">=</span> <span class="n">from</span> <span class="p">(</span><span class="n">deadline</span> <span class="n">dat</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span>
</pre></div>
</div>
<p>Remember that if the current slot was not in the <em>txInfoValidRange</em>,
then the validation script would not even be running.</p>
<p>That completes the validation logic. Let’s take care of some
boilerplate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Vesting</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Vesting</span> <span class="kr">where</span>
   <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="kt">VestingDatum</span>
   <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="nf">inst</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Vesting</span>
<span class="nf">inst</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Vesting</span>
   <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
   <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
<span class="kr">where</span>
   <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">VestingDatum</span> <span class="o">@</span><span class="nb">()</span>
</pre></div>
</div>
<p>We will focus more on the wallet part of the script later, but here are
the changes.</p>
<p>We have created a <em>GiveParams</em> type, and modified the <em>grab</em> endpoint to
require no parameters.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GiveParams</span> <span class="ow">=</span> <span class="kt">GiveParams</span>
   <span class="p">{</span> <span class="n">gpBeneficiary</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
   <span class="p">,</span> <span class="n">gpDeadline</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
   <span class="p">,</span> <span class="n">gpAmount</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">VestingSchema</span> <span class="ow">=</span>
   <span class="kt">BlockchainActions</span>
      <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;give&quot;</span> <span class="kt">GiveParams</span>
      <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;grab&quot;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>For the <em>give</em> endpoint, the <em>Datum</em> is constructed from the
<em>GiveParams</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">give</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">HasBlockchainActions</span> <span class="n">s</span><span class="p">,</span> <span class="kt">AsContractError</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">GiveParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">give</span> <span class="n">gp</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="kr">let</span> <span class="n">dat</span> <span class="ow">=</span> <span class="kt">VestingDatum</span>
               <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">=</span> <span class="n">gpBeneficiary</span> <span class="n">gp</span>
               <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">=</span> <span class="n">gpDeadline</span> <span class="n">gp</span>
               <span class="p">}</span>
      <span class="n">tx</span>  <span class="ow">=</span> <span class="n">mustPayToTheScript</span> <span class="n">dat</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="o">$</span> <span class="n">gpAmount</span> <span class="n">gp</span>
   <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="n">inst</span> <span class="n">tx</span>
   <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
   <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;made a gift of %d lovelace to %s with deadline %s&quot;</span>
      <span class="p">(</span><span class="n">gpAmount</span> <span class="n">gp</span><span class="p">)</span>
      <span class="p">(</span><span class="n">show</span> <span class="o">$</span> <span class="n">gpBeneficiary</span> <span class="n">gp</span><span class="p">)</span>
      <span class="p">(</span><span class="n">show</span> <span class="o">$</span> <span class="n">gpDeadline</span> <span class="n">gp</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>grab</em> endpoint is a bit more involved. Here, the grabber needs to
find the UTxOs that they can actually consume, which is performed by the
<em>isSuitable</em> helper function.</p>
<p>This looks at the all UTxOs and only keeps those that are suitable. It
first checks that the <em>Datum</em> hash exists, nad, if so, it deserialises
it, and, if that succeeds it checks that the beneficiary of the UTxO is
the public key hash of the grabber. It then checks that the deadline is
not in the future.</p>
<p>We see here that, from the wallet, we have access to the current slot
and to our own public key hash.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span><span class="o">.</span> <span class="p">(</span><span class="kt">HasBlockchainActions</span> <span class="n">s</span><span class="p">,</span> <span class="kt">AsContractError</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">grab</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="n">now</span>   <span class="ow">&lt;-</span> <span class="n">currentSlot</span>
   <span class="n">pkh</span>   <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="n">ownPubKey</span>
   <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="p">(</span><span class="n">isSuitable</span> <span class="n">pkh</span> <span class="n">now</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">utxoAt</span> <span class="n">scrAddress</span>
   <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="n">utxos</span>
      <span class="kr">then</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;no gifts available&quot;</span>
      <span class="kr">else</span> <span class="kr">do</span>
            <span class="kr">let</span> <span class="n">orefs</span>   <span class="ow">=</span> <span class="n">fst</span> <span class="o">&lt;$&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
               <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>  <span class="o">&lt;&gt;</span>
                        <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="n">validator</span>
               <span class="n">tx</span> <span class="ow">::</span> <span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span>
               <span class="n">tx</span>      <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span> <span class="o">|</span> <span class="n">oref</span> <span class="ow">&lt;-</span> <span class="n">orefs</span><span class="p">]</span> <span class="o">&lt;&gt;</span>
                        <span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="n">now</span><span class="p">)</span>
            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
            <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;collected gifts&quot;</span>
<span class="kr">where</span>
   <span class="n">isSuitable</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">Slot</span> <span class="ow">-&gt;</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
   <span class="n">isSuitable</span> <span class="n">pkh</span> <span class="n">now</span> <span class="n">o</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">txOutDatumHash</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span> <span class="kr">of</span>
      <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
      <span class="kt">Just</span> <span class="n">h</span>  <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">h</span> <span class="o">$</span> <span class="n">txData</span> <span class="o">$</span> <span class="n">txOutTxTx</span> <span class="n">o</span> <span class="kr">of</span>
            <span class="kt">Nothing</span>        <span class="ow">-&gt;</span> <span class="kt">False</span>
            <span class="kt">Just</span> <span class="p">(</span><span class="kt">Datum</span> <span class="n">e</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">fromData</span> <span class="n">e</span> <span class="kr">of</span>
               <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
               <span class="kt">Just</span> <span class="n">d</span>  <span class="ow">-&gt;</span> <span class="n">beneficiary</span> <span class="n">d</span> <span class="o">==</span> <span class="n">pkh</span> <span class="o">&amp;&amp;</span> <span class="n">deadline</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">now</span>
</pre></div>
</div>
<p>Note the call:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="n">now</span><span class="p">)</span>
</pre></div>
</div>
<p>If we do not do this, the default would be the infinite slot range, and
this would cause validation to fail in our case.</p>
<p>We could use a singleton slot here, but, if there were any issues, for
example network delays, and the transaction arrived at a node a slot or
two later, then validation would no longer work.</p>
<p>Another thing to note is that, if there is no suitable UTxO available,
we don’t even try to submit the transaction. We want to make sure that
when the grabber submits, they get something in return. Otherwise they
would have to pay fees for a transaction that doesn’t have any outputs.</p>
<div class="section" id="in-the-playground">
<h3><span class="section-number">4.4.1. </span>In the playground<a class="headerlink" href="#in-the-playground" title="Permalink to this headline">¶</a></h3>
<p>First, let’s get Wallet 1 to send some lovelace.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00004.png" />
</div>
<p>Here we run into a technical problem. We need to supply the beneficiary
address, but there is no way in the playground to get the public key
hash of a wallet.</p>
<p>But we can get it from the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Wallet.Emulator</span>
<span class="kt">Prelude</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Ledger</span>
<span class="kt">Prelude</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="o">$</span> <span class="kt">Wallet</span> <span class="mi">2</span>
<span class="mi">39</span><span class="n">f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f</span>
</pre></div>
</div>
<p>Let’s create a scenario where validation passes. Wallet 1 gives 500
lovelace with a deadline of slot 15. We wait for 15 slots, and then
Wallet 2 grabs.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00005.png" />
</div>
<p>After evaluation, we see the Genesis transaction, plus the give and the
grab transactions.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00006.png" />
</div>
<div class="figure align-default">
<img alt="" src="_images/week03__00007.png" />
</div>
<div class="figure align-default">
<img alt="" src="_images/week03__00008.png" />
</div>
<p>And the final balances.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00009.png" />
</div>
<p>Now let’s look at the case where the grab happens too early. We’ll
change the wait time to 14 slots.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00010.png" />
</div>
<p>Now we see just two transactions - the Genesis transaction, and the
give.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00012.png" />
</div>
<p>The grab transaction has failed validation.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00013.png" />
</div>
</div>
</div>
<div class="section" id="example-2-parameterized-contract">
<h2><span class="section-number">4.5. </span>Example 2 - Parameterized Contract<a class="headerlink" href="#example-2-parameterized-contract" title="Permalink to this headline">¶</a></h2>
<p>Our next example will be parameterized contracts, but let’s start with
an observation about our existing contract.</p>
<div class="section" id="an-observation">
<h3><span class="section-number">4.5.1. </span>An Observation<a class="headerlink" href="#an-observation" title="Permalink to this headline">¶</a></h3>
<p>We will set up a scenario where both wallets give and both wallets grab.</p>
<p>Again, in this example, the public key hash of Wallet 1’s address was
obtained from the REPL in the same way as with the Wallet 2 example
above.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00014.png" />
</div>
<p>After evaluation…</p>
<p>The Genesis transaction, as always.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00015.png" />
</div>
<p>The give of Wallet 2…</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00016.png" />
</div>
<p>The give of Wallet 1…</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00017.png" />
</div>
<p>The grab of Wallet 2…</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00018.png" />
</div>
<p>And, the grab of Wallet 1…</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00019.png" />
</div>
<p>Now, what we want to focus on here is the script addresses for the give
of Wallet 1 and the give of Wallet 2. If you look back at those
screenshots, you will notice that the script address in both cases is
the same.</p>
<p>And this is not surprising. Recall that the address of the script is
calculated by taken the hash of the compiled Plutus code of the
validator. Since the same validator is being used in both those
transactions, the script address is the same.</p>
<p>Keep this in mind for what we are about to cover in the following
section.</p>
</div>
<div class="section" id="another-way-of-doing-it">
<h3><span class="section-number">4.5.2. </span>Another Way of Doing It<a class="headerlink" href="#another-way-of-doing-it" title="Permalink to this headline">¶</a></h3>
<p>In our example, we have put the beneficiary and the deadline into the
datum. But there are other choices.</p>
<p>You could also parameterize the whole script on those two pieces of data
- the beneficiary and the deadline.</p>
<p>A parameterized script is like a family of scripts. You can instantiate
it with different parameters, and you get different scripts. They all
behave the same, but they have these different parameters.</p>
<p>We start by making a copy of Vesting.hs and creating a new module -
Week03.Parameterized.</p>
<p>Now, instead of using the <em>VestedDatum</em>, we are going to parameterize
the script with it. It makes sense to first change its name.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">VestingParam</span> <span class="ow">=</span> <span class="kt">VestingParam</span>
   <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span>
   <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">::</span> <span class="kt">Slot</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>Next, we will return to using Unit as our datum type, but we will add a
new validation argument, before the other arguments, of our new type
<em>VestingParam</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>The idea is that mkValidator is now a function that takes a VestingParam
and returns a custom validator based on those params.</p>
<p>We don’t need to change much, just the function header and the parts
that previously accessed the datum.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkValidator</span> <span class="n">p</span> <span class="nb">()</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span>
   <span class="n">traceIfFalse</span> <span class="s">&quot;beneficiary&#39;s signature missing&quot;</span> <span class="n">checkSig</span>      <span class="o">&amp;&amp;</span>
   <span class="n">traceIfFalse</span> <span class="s">&quot;deadline not reached&quot;</span>            <span class="n">checkDeadline</span>
<span class="kr">where</span>
   <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
   <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

   <span class="n">checkSig</span> <span class="ow">::</span> <span class="kt">Bool</span>
   <span class="n">checkSig</span> <span class="ow">=</span> <span class="n">beneficiary</span> <span class="n">p</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">txInfoSignatories</span> <span class="n">info</span>

   <span class="n">checkDeadline</span> <span class="ow">::</span> <span class="kt">Bool</span>
   <span class="n">checkDeadline</span> <span class="ow">=</span> <span class="n">from</span> <span class="p">(</span><span class="n">deadline</span> <span class="n">p</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span>
</pre></div>
</div>
<p>And, we need to change another piece of code that previously referenced
the datum.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Vesting</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Vesting</span> <span class="kr">where</span>
   <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="nb">()</span>
   <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>And now we come to an interesting question. What do we do here?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inst</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Vesting</span>
<span class="nf">inst</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Vesting</span>
   <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
   <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
<span class="kr">where</span>
   <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">VestingDatum</span> <span class="o">@</span><span class="nb">()</span>
</pre></div>
</div>
<p>As is, this won’t work because now <em>mkValidator</em> has the wrong type.
Remember that it must be a function that takes three arguments and
returns a boolean. But now, it has four arguments.</p>
<p>Also, we won’t always get the same instance, so this must now become a
function that takes <em>VestingParam</em> as an argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inst</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Vesting</span>
<span class="nf">inst</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Vesting</span>
</pre></div>
</div>
<p>The first idea would be to simply do something like this - adding the
<em>p</em> as a parameter, which would make the type correct again.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- this won&#39;t work</span>
<span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="n">p</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>But the problem is that, as we have seen before, in Template Haskell,
the things inside the Oxford Brackets must be known at compile time, but
the value of <em>p</em> here will not be known until runtime.</p>
<p>Luckily, there is a way around this.</p>
<p>We have something called applyCode, which takes two Plutus scripts, and,
assuming that the first one is a function, it applies this function to
the second argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- partial code</span>
<span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span> <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="c1">-- ...</span>
</pre></div>
</div>
<p>So, now, this…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>…is now a Plutus script for a function that takes such a parameter.
So, now, we must write a Plutus script for that parameter. Then
<em>applyCode</em> will apply the function to the script for the parameter, and
we will get a script of the right type out of that.</p>
<p>But this looks like it still doesn’t solve the problem because what do
we write after <em>applyCode</em>? How do we get the parameter there. We can’t
use PlutusTx.compile, as we have already seen.</p>
<p>This is where another important class comes in - the so-called <em>Lift</em>
class.</p>
<div class="section" id="the-lift-class">
<h4><span class="section-number">4.5.2.1. </span>The Lift Class<a class="headerlink" href="#the-lift-class" title="Permalink to this headline">¶</a></h4>
<p>The <em>Lift</em> class is defined in package <em>plutus-tx</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">PlutusTx.Lift.Class</span>
</pre></div>
</div>
<p>It only has one function, <em>Lift</em>. However, we won’t use this function
directly.</p>
<p>The importance of the class is that it allows us to, at runtime, lift
Haskell values into corresponding Plutus script values. And this is
exactly what we need to convert our parameter <em>p</em> into code.</p>
<p>We will use a different function, defined in the same package but in a
different module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">PlutusTx.Lift</span>
</pre></div>
</div>
<p>The function we will use is called <em>liftCode</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Get a Plutus Core program corresponding to the given value as a &#39;CompiledCodeIn&#39;, throwing any errors that occur as exceptions and ignoring fresh names.</span>
<span class="nf">liftCode</span>
   <span class="ow">::</span> <span class="p">(</span><span class="kt">Lift</span><span class="o">.</span><span class="kt">Lift</span> <span class="n">uni</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Throwable</span> <span class="n">uni</span> <span class="n">fun</span><span class="p">,</span> <span class="kt">PLC</span><span class="o">.</span><span class="kt">ToBuiltinMeaning</span> <span class="n">uni</span> <span class="n">fun</span><span class="p">)</span>
   <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">CompiledCodeIn</span> <span class="n">uni</span> <span class="n">fun</span> <span class="n">a</span>
<span class="nf">liftCode</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">unsafely</span> <span class="o">$</span> <span class="n">safeLiftCode</span> <span class="n">x</span>
</pre></div>
</div>
<p>It takes a Haskell value of type <em>a</em>, provided <em>a</em> is an instance of the
<em>Lift</em> class, and turns it into a piece of Plutus script code
corresponding to the same type.</p>
<p>So, let’s use that.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span> <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>There is still a problem, however. We need a <em>Lift</em> instance for <em>p</em>.</p>
<p>Luckily, similar to how we got an instance for <em>IsData</em> there is also a
Template Haskell function for <em>Lift</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">makeLift</span> <span class="kt">&#39;&#39;VestingParam</span>
</pre></div>
</div>
<p>But, it still won’t compile. We need another GHC extension.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE MultiParamTypeClasses #-}</span>
</pre></div>
</div>
<p>Now we have to some more little modifications.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">validator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">validator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">inst</span>

<span class="nf">scrAddress</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">scrAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">validator</span>
</pre></div>
</div>
<p>Changes are also necessary in the wallet part.</p>
<p>The <em>GiveParams</em> stay the same, but the endpoints are slightly
different, because in the <em>grab</em> endpoint earlier we only had the Unit
argument, but now we need the slot.</p>
<p>This is because, in order to construct the address that we grab from, we
need the params - the beneficiary and the deadline. We already now the
beneficiary, as it will be the address of the wallet that is doing the
grabbing, but we need to pass in the slot value for the deadline.</p>
<p>In the <em>give</em> endpoint, there are also some differences.</p>
<p>Whenever we need an <em>inst</em> we must pass in the params.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">inst</span> <span class="n">p</span><span class="p">)</span> <span class="n">tx</span>
</pre></div>
</div>
<p>And in the <em>grab</em> endpoint, we have the additional parameter.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="n">d</span> <span class="ow">=</span> <span class="kr">do</span>
</pre></div>
</div>
<p>And we can use that to construct the parameters, along with our own
public key hash.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">VestingParam</span>
            <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">=</span> <span class="n">pkh</span>
            <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">=</span> <span class="n">d</span>
            <span class="p">}</span>
</pre></div>
</div>
<p>And again, when we use something like <em>scrAddress</em>, we need to pass in
the parameters.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="o">$</span> <span class="n">scrAddress</span> <span class="n">p</span>
</pre></div>
</div>
<p>Now, the good thing with this is that we don’t need the filter helper
function <em>isSuitable</em> anymore. Previously, we got all the UTxOs sitting
at the script address and filtered them based on beneficiary and
deadline. But now, it’s much easier because the script is already
parameterized by beneficiary, so we know that this script will only hold
UTxOs that are for us.</p>
<p>So, all we need to do is to check that <em>now</em> is not earlier than the
deadline.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">d</span>
   <span class="kr">then</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;too early&quot;</span>
   <span class="kr">else</span> <span class="kr">do</span>
   <span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="back-to-the-playground">
<h3><span class="section-number">4.5.3. </span>Back to the playground<a class="headerlink" href="#back-to-the-playground" title="Permalink to this headline">¶</a></h3>
<p>If we copy paste this new contract into the playground and setup the
same scenario as before…</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00020.png" />
</div>
<p>We can see that now, one of the disadvantages to doing it this way is
that the wallets now need to know the deadline in order to construct the
script address.</p>
<p>If you evaluate this, you will see that it succeeds.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00021.png" />
</div>
<p>But now, compare the script address that Wallet 1 sends to with the
script address that Wallet 2 sends to.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00022.png" />
</div>
<p>They are now different. The UTxOs are being held at different addresses.</p>
<p>This is because of the parameters. The same script but with different
parameters will have a different hash.</p>
<p>Whether this is a good thing or a bad thing will depend on the use case.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="week4.html" class="btn btn-neutral float-right" title="5. Week 04 - Monads" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="week2.html" class="btn btn-neutral float-left" title="3. Week 02 - Validation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>